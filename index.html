<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>MMORPG åŸå‹ - æ‰‹æ©Ÿè§¸æ§ç‰ˆ</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        html, body { height: 100%; }
        body { 
            background: linear-gradient(135deg, #0a0a0a, #1a1a2e);
            color: #fff;
            font-family: 'Arial Black', Arial, sans-serif;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }
        canvas {
            display:block;
            width:100vw;
            height:100vh;
            background: radial-gradient(circle at center, #2a2a4a 0%, #111 70%);
            cursor: none; /* hide mouse cursor; mobile-friendly */
        }
        #ui {
            position: fixed; top: 12px; left: 12px;
            background: rgba(0,0,0,0.75);
            padding: 12px 16px;
            border-radius: 12px;
            font-size: clamp(12px, 3.5vw, 16px);
            backdrop-filter: blur(6px);
            z-index: 60;
            box-shadow: 0 0 18px rgba(0,255,255,0.14);
        }
        #bottomUI {
            position: fixed; bottom: 18px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.75); padding: 10px 14px; border-radius: 16px;
            display:flex; gap:12px; align-items:center; z-index:60;
        }
        .skill-btn {
            width: 64px; height:64px; border-radius: 50%;
            display:flex; align-items:center; justify-content:center;
            font-size:28px; background: linear-gradient(45deg,#4A90E2,#357ABD);
            color:#fff; border:2px solid rgba(255,255,255,0.08);
            box-shadow: 0 6px 18px rgba(0,0,0,0.5);
            touch-action: none;
        }
        .skill-btn.cd { opacity:0.5; }
        .cd-bar { position: absolute; bottom: -6px; left: 50%; transform: translateX(-50%); width:76%; height:6px; background: rgba(255,255,255,0.12); border-radius: 4px; overflow:hidden; }
        .cd-fill { height:100%; width:0%; background: linear-gradient(90deg,#ff0000,#ffff00); transition: width 0.08s linear; }
        #controls { position: fixed; bottom: 16px; right: 16px; background: rgba(0,0,0,0.6); padding:10px; border-radius:12px; font-size:12px; z-index:60; color:#ccc; }
        #shopBtn { position: fixed; top: 50%; right: 14px; transform: translateY(-50%); width:50px; height:50px; border-radius:50%; background:#FFD700; color:#000; border:none; font-size:20px; z-index:60; box-shadow:0 0 20px #FFD700; touch-action:none; }
        #shopModal, #classSelect, #inventory { display:none; position:fixed; inset:0; background: rgba(0,0,0,0.9); z-index:80; align-items:center; justify-content:center; }
        #shopContent, #classContent, #invContent { background:#222; padding:24px; border-radius:16px; text-align:center; max-width:92%; width:360px; }
        .item-btn, .class-btn { margin:10px; padding:12px 18px; background:#4CAF50; color:#fff; border:none; border-radius:10px; font-size:16px; touch-action:none; }
        .class-btn { background: linear-gradient(45deg,#4A90E2,#357ABD); }
        #invList { max-height:300px; overflow:auto; text-align:left; margin-top:8px; }
        .equip-btn { width:100%; margin:6px 0; padding:10px; border-radius:8px; background:#FFD700; color:#000; border:none; }
        /* joystick */
        #joystickContainer { position: fixed; left: 14px; bottom: 18px; width: 140px; height:140px; border-radius:50%; z-index:70; touch-action:none; display:flex; align-items:center; justify-content:center; }
        #joystickBg { width: 120px; height:120px; background: rgba(255,255,255,0.03); border-radius:50%; display:block; position:relative; }
        #joystickKnob { width:54px; height:54px; position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); border-radius:50%; background: rgba(255,255,255,0.06); display:flex; align-items:center; justify-content:center; font-size:18px; touch-action:none; }
        /* ensure large clickable areas on mobile */
        .big-touch { padding:12px 18px; border-radius:12px; }
        @media (pointer: coarse) {
            .skill-btn { width:72px; height:72px; font-size:32px; }
            #joystickContainer { width:160px; height:160px; }
            #joystickBg { width:140px; height:140px; }
            #joystickKnob { width:64px; height:64px; }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div id="ui">
        <div>è·æ¥­: <span id="playerClass">æœªé¸æ“‡</span></div>
        <div>ç­‰ç´š: <span id="playerLevel">1</span> | EXP: <span id="exp">0</span>/<span id="nextExp">100</span></div>
        <div>HP: <span id="playerHp">100</span>/<span id="playerMaxHp">100</span> | é‡‘å¹£: <span id="gold">0</span></div>
        <div>æ€ªç‰©: <span id="monsterCount">0</span></div>
    </div>

    <div id="joystickContainer" aria-hidden="true">
        <div id="joystickBg"><div id="joystickKnob">â—</div></div>
    </div>

    <div id="bottomUI" aria-hidden="false">
        <div class="skill-btn" id="skill1" title="Q:è¡åˆºæ–¬">âš”ï¸
            <div class="cd-bar"><div class="cd-fill" id="cd1"></div></div>
        </div>
        <div class="skill-btn" id="skill2" title="E:æ—‹è½‰æ–¬">ğŸŒ€
            <div class="cd-bar"><div class="cd-fill" id="cd2"></div></div>
        </div>
        <div class="skill-btn" id="skill3" title="R:é ç¨‹ç®­">ğŸ¹
            <div class="cd-bar"><div class="cd-fill" id="cd3"></div></div>
        </div>
    </div>

    <div id="controls">è™›æ“¬æ–æ¡¿ç§»å‹• â€¢ æŠ€èƒ½æŒ‰éˆ•æ–½æ”¾ â€¢ é»æ“Šåœ°é¢å¿«é€Ÿç§»å‹•</div>
    <button id="shopBtn" title="å•†åº—">ğŸ›’</button>

    <div id="shopModal">
        <div id="shopContent">
            <h2>å•†åº—</h2>
            <p>é‡‘å¹£: <span id="shopGold">0</span></p>
            <button class="item-btn big-touch" onclick="buyPotion()">HPè—¥æ°´ x5 (50é‡‘)</button>
            <button class="item-btn big-touch" onclick="buySpeed()">é€Ÿåº¦+1 (200é‡‘)</button>
            <button class="item-btn big-touch" onclick="closeShop()">é—œé–‰</button>
        </div>
    </div>

    <div id="classSelect">
        <div id="classContent">
            <h2>é¸æ“‡è·æ¥­</h2>
            <p>æ±ºå®šä½ çš„éŠç©é¢¨æ ¼</p>
            <button class="class-btn big-touch" onclick="selectClass('warrior')">âš”ï¸ æˆ°å£«<br>é«˜å‚·è¿‘æˆ°</button>
            <button class="class-btn big-touch" onclick="selectClass('mage')">ğŸ”® æ³•å¸«<br>AoE é ç¨‹</button>
            <button class="class-btn big-touch" onclick="selectClass('ranger')">ğŸ¹ éŠä¿ <br>å¯µç‰©è¼”åŠ©</button>
        </div>
    </div>

    <div id="inventory">
        <div id="invContent">
            <h2>èƒŒåŒ…</h2>
            <div id="invList"></div>
            <button class="item-btn big-touch" onclick="closeInv()">é—œé–‰</button>
        </div>
    </div>

    <script>
    // ---------- åŸºæœ¬è¨­å®š ----------
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const dpr = Math.max(1, window.devicePixelRatio || 1);

    function resizeCanvas() {
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';
        canvas.width = Math.floor(window.innerWidth * dpr);
        canvas.height = Math.floor(window.innerHeight * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // scale drawing to CSS pixels
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    const elements = {
        playerClassEl: document.getElementById('playerClass'),
        playerLevel: document.getElementById('playerLevel'),
        exp: document.getElementById('exp'),
        nextExp: document.getElementById('nextExp'),
        playerHp: document.getElementById('playerHp'),
        playerMaxHp: document.getElementById('playerMaxHp'),
        gold: document.getElementById('gold'),
        monsterCount: document.getElementById('monsterCount'),
        shopGold: document.getElementById('shopGold'),
        skill1: document.getElementById('skill1'),
        skill2: document.getElementById('skill2'),
        skill3: document.getElementById('skill3'),
        cd1: document.getElementById('cd1'),
        cd2: document.getElementById('cd2'),
        cd3: document.getElementById('cd3'),
        invList: document.getElementById('invList')
    };

    // Audio
    let audioCtx = null;
    function ensureAudio() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
    }
    function playSound(freq, duration, type = 'sine') {
        try {
            ensureAudio();
            let oscillator = audioCtx.createOscillator();
            let gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            oscillator.frequency.value = freq;
            oscillator.type = type;
            gainNode.gain.setValueAtTime(0.25, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + duration);
        } catch (e) { /* mobile auto-play restrictions might block audio until user gesture */ }
    }

    // ---------- éŠæˆ²ç‹€æ…‹ ----------
    let playerClass = null;
    let player = {
        x: 0, y: 0, hp: 100, maxHp: 100, level: 1, exp: 0, nextExp: 100, gold: 0,
        speed: 5, size: 25, vx: 0, vy: 0, lastAttack: 0, dodgeTime: 0, dodgeCD: 0,
        dmgMod: 1, aoeRange: 60, petActive: false
    };
    let inventory = [];
    let equipped = { hpBonus: 0, dmgBonus: 0 };
    let monsters = [];
    let particles = [];
    let projectiles = [];
    let targetX = 0, targetY = 0, hasTarget = false;
    let keys = {}, gameOver = false, gameStarted = false;
    const MAX_MONSTERS = 5;
    const ATTACK_INTERVAL = 800;
    const DODGE_CD = 3000, DODGE_TIME = 800;

    const skills = [
        { name: 'dashSlash', key: 'q', cd: 2000, active: false, cdTime: 0 },
        { name: 'spinSlash', key: 'e', cd: 3000, active: false, cdTime: 0 },
        { name: 'arrow', key: 'r', cd: 2500, active: false, cdTime: 0 }
    ];

    const classConfig = {
        warrior: { speed: 4.8, dmgMod: 1.5, aoeRange: 50, petActive: false, skillMods: {0: {cd:1500}, 1: {dmg:1.3}} },
        mage:    { speed: 5.5, dmgMod: 1.2, aoeRange: 90, petActive: false, skillMods: {1: {range:1.5, dmg:1.4}, 2: {dmg:1.5}} },
        ranger:  { speed: 5.2, dmgMod: 1.3, aoeRange: 70, petActive: true,  skillMods: {2: {speed:1.5, count:2}} }
    };

    // ---------- åˆå§‹èˆ‡é‡ç½® ----------
    function initPlayer() {
        player.x = canvas.width / (2 * dpr);
        player.y = canvas.height / (2 * dpr);
        targetX = player.x; targetY = player.y; hasTarget = false;
    }

    function resetGame() {
        player.hp = player.maxHp;
        player.level = 1;
        player.exp = 0;
        player.nextExp = 100;
        player.gold = 0;
        player.speed = classConfig[playerClass]?.speed || 5;
        monsters = [];
        particles = [];
        projectiles = [];
        gameOver = false;
        initPlayer();
        for (let i = 0; i < 3; i++) spawnMonster();
    }

    // ---------- æ€ªç‰© / ç²’å­ / æŠ•å°„ç‰© ----------
    function spawnMonster() {
        if (!gameStarted) return;
        if (monsters.length < MAX_MONSTERS) {
            monsters.push({
                x: Math.random() * (canvas.width/dpr - 100) + 50,
                y: Math.random() * (canvas.height/dpr - 100) + 50,
                hp: 40 + player.level * 10, maxHp: 40 + player.level * 10,
                speed: 1.8 + player.level * 0.2, size: 20, lastAttack: 0, alive: true,
                goldDrop: 10 + Math.floor(Math.random() * 20)
            });
        }
    }

    function createParticles(x, y, color, count = 15, speed = 5, life = 40) {
        for (let i = 0; i < count; i++) {
            particles.push({
                x, y, vx: (Math.random() - 0.5) * speed, vy: (Math.random() - 0.5) * speed,
                life, maxLife: life, color, size: Math.random() * 4 + 2
            });
        }
    }

    function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.vx; p.y += p.vy;
            p.life--;
            p.size *= 0.98;
            if (p.life <= 0) { particles.splice(i,1); continue; }
            ctx.save();
            ctx.globalAlpha = Math.max(0, p.life / p.maxLife);
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
            ctx.fill();
            ctx.restore();
        }
    }

    function updateProjectiles() {
        for (let i = projectiles.length - 1; i >= 0; i--) {
            let proj = projectiles[i];
            proj.x += proj.vx; proj.y += proj.vy;
            if (proj.x < -50 || proj.x > canvas.width/dpr + 50 || proj.y < -50 || proj.y > canvas.height/dpr + 50) {
                projectiles.splice(i,1); continue;
            }
            ctx.save();
            ctx.translate(proj.x, proj.y);
            ctx.fillStyle = proj.color;
            ctx.shadowBlur = 10;
            ctx.shadowColor = proj.color;
            ctx.beginPath();
            ctx.arc(0,0,proj.size,0,Math.PI*2);
            ctx.fill();
            ctx.restore();

            for (let j = monsters.length - 1; j >= 0; j--) {
                let m = monsters[j];
                if (m.alive && Math.hypot(m.x - proj.x, m.y - proj.y) < 30) {
                    m.hp -= (25 + player.level * 3) * player.dmgMod;
                    createParticles(m.x, m.y, '#FFD700', 20);
                    playSound(800, 0.12);
                    projectiles.splice(i,1);
                    if (m.hp <= 0) killMonster(m);
                    break;
                }
            }
        }
    }

    // ---------- æˆ°é¬¥ / æ‰è½ / å‡ç´š ----------
    function killMonster(m) {
        player.exp += 20 + player.level * 5;
        player.gold += m.goldDrop;
        createParticles(m.x, m.y, '#FF4444', 30, 8);
        playSound(200, 0.18, 'square');
        dropLoot();
        if (player.exp >= player.nextExp) levelUp();
        m.alive = false;
        setTimeout(() => {
            let idx = monsters.indexOf(m);
            if (idx > -1) monsters.splice(idx,1);
        }, 800);
    }

    function dropLoot() {
        if (Math.random() < 0.2) {
            let names = playerClass === 'warrior' ? ['éµåŠ','æˆ°æ–§'] : playerClass === 'mage' ? ['æ³•æ–','é­”æ™¶'] : ['çµå¼“','ç®­è¢‹'];
            let loot = {
                name: names[Math.floor(Math.random() * names.length)],
                rarity: Math.random() > 0.6 ? 'ç´«' : Math.random() > 0.3 ? 'è—' : 'ç¶ ',
                hp: 15 + Math.random() * 35,
                dmg: 4 + Math.random() * 12
            };
            inventory.push(loot);
            createParticles(player.x, player.y, '#FFD700', 10);
            playSound(1000, 0.12);
        }
    }

    function levelUp() {
        player.level++;
        player.exp = 0;
        player.nextExp = Math.floor(player.nextExp * 1.5);
        player.maxHp += 30 + equipped.hpBonus * 0.1;
        player.hp = player.maxHp;
        player.speed += 0.3;
        createParticles(player.x, player.y, '#00FF88', 50, 10);
        playSound(1200, 0.28);
    }

    // ---------- æŠ€èƒ½ç³»çµ±ï¼ˆè·æ¥­åŒ–ï¼‰ ----------
    function useSkill(index) {
        let skill = skills[index];
        if (Date.now() - skill.cdTime < skill.cd) return;
        let config = classConfig[playerClass]?.skillMods?.[index] || {};
        skill.cdTime = Date.now();
        skill.active = true;
        playSound(900 + index*200, 0.12);
        updateSkillUI();
        setTimeout(() => { skill.active = false; }, 300);
    }

    function updateSkillUI() {
        skills.forEach((s, i) => {
            let btn = elements[`skill${i+1}`];
            let cd = elements[`cd${i+1}`];
            let progress = Math.max(0, 1 - (Date.now() - s.cdTime) / s.cd);
            btn.classList.toggle('cd', progress > 0 && !s.active);
            cd.style.width = `${progress * 100}%`;
        });
    }

    // ---------- å•†åº— / èƒŒåŒ… ----------
    function toggleShop() {
        let modal = document.getElementById('shopModal');
        elements.shopGold.textContent = player.gold;
        modal.style.display = modal.style.display === 'flex' ? 'none' : 'flex';
    }
    function buyPotion() {
        if (player.gold >= 50) {
            player.gold -= 50;
            player.hp = Math.min(player.maxHp, player.hp + 100);
            playSound(900, 0.18);
            elements.shopGold.textContent = player.gold;
        }
    }
    function buySpeed() {
        if (player.gold >= 200) {
            player.gold -= 200;
            player.speed += 1;
            playSound(1100, 0.18);
            elements.shopGold.textContent = player.gold;
        }
    }
    function closeShop() { document.getElementById('shopModal').style.display = 'none'; }

    function toggleInv() {
        elements.invList.innerHTML = inventory.map((item, i) =>
            `<button class="equip-btn" onclick="equipItem(${i})">${item.name} [${item.rarity}] +${Math.floor(item.hp)}HP +${Math.floor(item.dmg)}å‚·</button>`
        ).join('') || '<div style="color:#ccc;padding:6px">èƒŒåŒ…ç©º</div>';
        document.getElementById('inventory').style.display = 'flex';
    }
    function equipItem(i) {
        let item = inventory.splice(i,1)[0];
        equipped.hpBonus += item.hp;
        equipped.dmgBonus += item.dmg;
        player.maxHp += item.hp;
        player.hp += item.hp;
        player.dmgMod += item.dmg / 100;
        playSound(950, 0.2);
        toggleInv();
    }
    function closeInv() { document.getElementById('inventory').style.display = 'none'; }

    // ---------- è¼”åŠ©å‡½æ•¸ ----------
    function distance(o1, o2) { if(!o1||!o2) return Infinity; return Math.hypot(o1.x - o2.x, o1.y - o2.y); }

    // ---------- äº‹ä»¶ç¶å®šï¼ˆéµç›¤ & pointerï¼‰ ----------
    window.addEventListener('keydown', (e) => {
        let key = e.key.toLowerCase();
        keys[key] = true;
        if (key === 'r' && gameOver) resetGame();
        if (key === 's') toggleShop();
        if (key === 'i') toggleInv();
        skills.forEach((s, i) => { if (key === s.key) useSkill(i); });
    });
    window.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });

    // pointer é»æ“Šç§»å‹•ï¼ˆé»æ“Šåœ°é¢å¿«é€Ÿç§»å‹•ï¼‰
    canvas.addEventListener('pointerdown', (e) => {
        // å¦‚æœæ–æ¡¿æˆ– UI æ•ç²å‰‡ skipï¼ˆæ–æ¡¿æœƒä½¿ç”¨ pointer captureï¼‰
        const rect = canvas.getBoundingClientRect();
        const px = (e.clientX - rect.left) * (canvas.width/rect.width) / dpr;
        const py = (e.clientY - rect.top)  * (canvas.height/rect.height) / dpr;
        // é»åˆ°ä¸‹æ–¹æŠ€èƒ½æŒ‰éˆ•æˆ– joystick çš„è©±ä¸è¦æ”¹è®Šé»ç§»å‹•ç›®æ¨™
        // æˆ‘å€‘å‡è¨­ UI å€åŸŸåœ¨é é¢ä¸Šæ–¹/åº•éƒ¨ï¼Œè‹¥ pointer target æ˜¯ canvas æ‰å•Ÿå‹•ç§»å‹•
        if (e.target === canvas) {
            targetX = px; targetY = py; hasTarget = true;
        }
    }, { passive: true });

    // æŠ€èƒ½æŒ‰éˆ• touch æ”¯æ´ï¼ˆé¿å… click delayï¼‰
    ['skill1','skill2','skill3'].forEach((id, idx) => {
        const el = document.getElementById(id);
        function onActivate(ev) {
            ev.preventDefault();
            useSkill(idx);
            // small visual feedback
            el.animate([{ transform: 'scale(1)' }, { transform: 'scale(0.92)' }, { transform: 'scale(1)' }], { duration: 120 });
        }
        el.addEventListener('pointerdown', onActivate);
        el.addEventListener('touchstart', onActivate, { passive:false });
    });

    // UI buttons
    document.getElementById('shopBtn').addEventListener('pointerdown', (e) => { e.preventDefault(); toggleShop(); }, { passive:false });

    // class select (already uses onclick handlers)

    // ---------- è™›æ“¬æ–æ¡¿ï¼ˆæ”¯æŒå¤šæŒ‡ï¼‰ ----------
    const joystickContainer = document.getElementById('joystickContainer');
    const joystickKnob = document.getElementById('joystickKnob');
    const joystickBg = document.getElementById('joystickBg');
    let joyActive = false, joyId = null, joyStart = {x:0,y:0}, joyPos = {x:0,y:0};
    const JOY_MAX = 44; // knob radius limit in CSS pixels

    joystickBg.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        joystickBg.setPointerCapture(e.pointerId);
        joyActive = true; joyId = e.pointerId;
        const rect = joystickBg.getBoundingClientRect();
        joyStart = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
        updateJoystick(e.clientX, e.clientY);
    }, { passive: false });

    joystickBg.addEventListener('pointermove', (e) => {
        if (!joyActive || e.pointerId !== joyId) return;
        updateJoystick(e.clientX, e.clientY);
    }, { passive: true });

    joystickBg.addEventListener('pointerup', (e) => {
        if (e.pointerId !== joyId) return;
        joyActive = false; joyId = null;
        joystickKnob.style.transform = 'translate(-50%,-50%)';
        joyPos = { x:0, y:0 };
    });
    joystickBg.addEventListener('pointercancel', (e) => {
        joyActive = false; joyId = null;
        joystickKnob.style.transform = 'translate(-50%,-50%)';
        joyPos = { x:0, y:0 };
    });

    function updateJoystick(clientX, clientY) {
        const dx = clientX - joyStart.x;
        const dy = clientY - joyStart.y;
        const dist = Math.hypot(dx,dy);
        const angle = Math.atan2(dy,dx);
        const limited = Math.min(JOY_MAX, dist);
        const knobX = Math.cos(angle) * limited;
        const knobY = Math.sin(angle) * limited;
        joystickKnob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`;
        joyPos = { x: knobX / JOY_MAX, y: knobY / JOY_MAX }; // -1..1
    }

    // ---------- æ›´æ–°é‚è¼¯ ----------
    function update() {
        if (gameOver || !gameStarted) return;

        // joystick control has priority for movement
        let vx = 0, vy = 0;
        if (joyPos.x !== 0 || joyPos.y !== 0) {
            vx += joyPos.x * player.speed;
            vy += joyPos.y * player.speed;
        } else {
            if (keys['w'] || keys['arrowup']) vy -= player.speed;
            if (keys['s'] || keys['arrowdown']) vy += player.speed;
            if (keys['a'] || keys['arrowleft']) vx -= player.speed;
            if (keys['d'] || keys['arrowright']) vx += player.speed;
            if (hasTarget) {
                let dx = targetX - player.x, dy = targetY - player.y;
                let dist = Math.hypot(dx, dy);
                if (dist > 20) {
                    vx += (dx / dist) * player.speed * 0.7;
                    vy += (dy / dist) * player.speed * 0.7;
                } else {
                    hasTarget = false;
                }
            }
        }

        let speed = Math.hypot(vx, vy);
        if (speed > player.speed * 1.4) {
            vx = (vx / speed) * player.speed * 1.4;
            vy = (vy / speed) * player.speed * 1.4;
        }

        // dodge (Shift or double-tap? keep Shift for desktop)
        if ((keys['shift'] || false) && Date.now() - player.dodgeCD > DODGE_CD) {
            player.dodgeTime = Date.now() + DODGE_TIME;
            player.dodgeCD = Date.now();
            player.vx = vx * 2.5;
            player.vy = vy * 2.5;
            createParticles(player.x, player.y, '#00FFFF', 25);
            playSound(1400, 0.1);
        }
        if (Date.now() < player.dodgeTime) {
            player.x += player.vx * 0.1;
            player.y += player.vy * 0.1;
        }

        player.x += vx * 0.1;
        player.y += vy * 0.1;
        player.x = Math.max(player.size, Math.min(canvas.width/dpr - player.size, player.x));
        player.y = Math.max(player.size, Math.min(canvas.height/dpr - player.size, player.y));

        // monsters AI & combat
        let aliveMonsters = monsters.filter(m => m.alive);
        aliveMonsters.forEach(m => {
            let dx = player.x - m.x, dy = player.y - m.y;
            let dist = Math.hypot(dx, dy);
            if (dist > 40) {
                m.x += (dx / dist) * m.speed;
                m.y += (dy / dist) * m.speed;
            }
            m.x = Math.max(m.size, Math.min(canvas.width/dpr - m.size, m.x));
            m.y = Math.max(m.size, Math.min(canvas.height/dpr - m.size, m.y));

            if (dist < 45 && Date.now() - player.lastAttack > ATTACK_INTERVAL && Date.now() > player.dodgeTime) {
                m.hp -= (15 + player.level * 3) * player.dmgMod;
                player.lastAttack = Date.now();
                createParticles(m.x, m.y, '#4A90E2', 12);
                playSound(600, 0.08);
                if (m.hp <= 0) killMonster(m);
            }
            if (dist < 45 && Date.now() - m.lastAttack > 1200) {
                if (Date.now() > player.dodgeTime) player.hp -= 10;
                m.lastAttack = Date.now();
                createParticles(player.x, player.y, '#E74C3C', 8);
                playSound(300, 0.12);
            }
        });

        // skills effects
        skills.forEach((s, index) => {
            if (s.active) {
                let mod = classConfig[playerClass]?.skillMods?.[index] || {};
                switch (s.name) {
                    case 'dashSlash':
                        let angle = Math.atan2(targetY - player.y, targetX - player.x);
                        player.x += Math.cos(angle) * 100 * 0.05;
                        player.y += Math.sin(angle) * 100 * 0.05;
                        aliveMonsters.forEach(m => {
                            if (distance(player, m) < (50 + (mod.range || 0) * 20)) {
                                m.hp -= (30 + player.level * 5) * (mod.dmg || 1) * player.dmgMod;
                                createParticles(m.x, m.y, '#FFAA00');
                            }
                        });
                        break;
                    case 'spinSlash':
                        aliveMonsters.forEach(m => {
                            if (distance(player, m) < (player.aoeRange * (mod.range || 1))) {
                                m.hp -= (20 + player.level * 4) * (mod.dmg || 1) * player.dmgMod;
                                createParticles(m.x, m.y, '#FF6600', 18);
                            }
                        });
                        break;
                    case 'arrow':
                        let projCount = mod.count || 1;
                        for (let k = 0; k < projCount; k++) {
                            let ang = Math.atan2(targetY - player.y, targetX - player.x) + (k - (projCount-1)/2) * 0.18;
                            projectiles.push({
                                x: player.x, y: player.y,
                                vx: Math.cos(ang) * (12 * (mod.speed || 1)),
                                vy: Math.sin(ang) * (12 * (mod.speed || 1)),
                                size: 4, color: '#FFD700'
                            });
                        }
                        break;
                }
            }
        });

        // pet for ranger
        if (player.petActive && playerClass === 'ranger') {
            let nearest = aliveMonsters.reduce((closest, m) => !closest || distance(player, m) < distance(player, closest) ? m : closest, null);
            if (nearest) {
                createParticles(nearest.x, nearest.y, '#00AAFF', 3, 2);
                nearest.hp -= 5 * player.dmgMod * 0.5;
                if (nearest.hp <= 0) killMonster(nearest);
            }
        }

        if (player.hp <= 0) gameOver = true;
        if (aliveMonsters.length < MAX_MONSTERS * 0.6) spawnMonster();
    }

    // ---------- ç¹ªè£½ ----------
    function draw() {
        // clear using CSS sized canvas (we set transform earlier)
        ctx.clearRect(0,0,canvas.width/dpr, canvas.height/dpr);

        // subtle background stars
        ctx.fillStyle = 'rgba(100,150,255,0.02)';
        for (let i=0;i<40;i++){
            ctx.beginPath();
            ctx.arc(Math.random() * canvas.width/dpr, Math.random() * canvas.height/dpr, 0.7, 0, Math.PI*2);
            ctx.fill();
        }

        updateParticles();
        updateProjectiles();

        // player
        ctx.save();
        ctx.translate(player.x, player.y);
        let playerGlow = Date.now() < player.dodgeTime ? Math.sin(Date.now() * 0.02) * 15 : 0;
        ctx.shadowBlur = 30 + playerGlow;
        ctx.shadowColor = Date.now() < player.dodgeTime ? '#00FFFF' : '#4A90E2';
        ctx.fillStyle = playerClass === 'warrior' ? '#FF6B35' : playerClass === 'mage' ? '#9B59B6' : '#27AE60';
        ctx.beginPath();
        ctx.arc(0,0,player.size,0,Math.PI*2);
        ctx.fill();
        ctx.restore();

        // HP bar
        let barWidth = Math.min(120, (canvas.width/dpr) * 0.12), barHeight = 14;
        let hpRatio = player.hp / player.maxHp;
        ctx.fillStyle = 'rgba(0,0,0,0.75)';
        ctx.fillRect(player.x - barWidth/2, player.y - player.size - 28, barWidth, barHeight);
        ctx.fillStyle = hpRatio > 0.6 ? '#4CAF50' : hpRatio > 0.3 ? '#FF9800' : '#F44336';
        ctx.fillRect(player.x - barWidth/2, player.y - player.size - 28, barWidth * Math.max(0, hpRatio), barHeight);

        // monsters
        monsters.filter(m => m.alive).forEach(m => {
            ctx.save();
            ctx.translate(m.x, m.y);
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#E74C3C';
            ctx.fillStyle = '#E74C3C';
            ctx.beginPath();
            ctx.arc(0,0,m.size,0,Math.PI*2);
            ctx.fill();
            ctx.restore();

            let mHpRatio = m.hp / m.maxHp;
            ctx.fillStyle = 'rgba(0,0,0,0.75)';
            ctx.fillRect(m.x - barWidth/2 * 0.9, m.y - m.size - 22, barWidth*0.9, barHeight*0.8);
            ctx.fillStyle = mHpRatio > 0.6 ? '#4CAF50' : mHpRatio > 0.3 ? '#FF9800' : '#F44336';
            ctx.fillRect(m.x - barWidth/2 * 0.9, m.y - m.size - 22, barWidth*0.9 * Math.max(0, mHpRatio), barHeight*0.8);
        });

        // game over overlay
        if (gameOver) {
            ctx.fillStyle = 'rgba(0,0,0,0.9)';
            ctx.fillRect(0,0,canvas.width/dpr, canvas.height/dpr);
            ctx.fillStyle = '#FFD700';
            ctx.font = `bold ${Math.min(72, (canvas.width/dpr) * 0.09)}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText('éŠæˆ²çµæŸï¼', canvas.width/dpr / 2, canvas.height/dpr / 2);
            ctx.font = `${Math.min(36, (canvas.width/dpr) * 0.06)}px Arial`;
            ctx.fillText('æŒ‰ R æˆ–é‡æ–°é¸æ“‡è·æ¥­ä»¥é‡å•Ÿ', canvas.width/dpr / 2, canvas.height/dpr / 2 + 50);
        }
    }

    // ---------- ä¸»å¾ªç’° ----------
    function updateUI() {
        elements.playerLevel.textContent = player.level;
        elements.exp.textContent = player.exp;
        elements.nextExp.textContent = player.nextExp;
        elements.playerHp.textContent = Math.floor(player.hp);
        elements.playerMaxHp.textContent = Math.floor(player.maxHp);
        elements.gold.textContent = player.gold;
        elements.monsterCount.textContent = monsters.filter(m => m.alive).length;
        elements.shopGold.textContent = player.gold;
        updateSkillUI();
    }

    function gameLoop() {
        update();
        draw();
        updateUI();
        requestAnimationFrame(gameLoop);
    }

    // ---------- é¸è· / å•Ÿå‹• ----------
    function selectClass(cls) {
        playerClass = cls;
        const config = classConfig[cls];
        player.speed = config.speed;
        player.dmgMod = config.dmgMod;
        player.aoeRange = config.aoeRange;
        player.petActive = config.petActive;
        elements.playerClassEl.textContent = cls;
        document.getElementById('classSelect').style.display = 'none';
        resetGame();
        gameStarted = true;
    }

    // é¡¯ç¤º class é¸å–®å•Ÿå‹•éŠæˆ²
    document.getElementById('classSelect').style.display = 'flex';
    gameLoop();

    // ---------- æ–¹ä¾¿çš„å¤–éƒ¨å‘¼å«ï¼ˆçµ¦ HTML æŒ‰éˆ•ï¼‰ ----------
    window.toggleShop = toggleShop;
    window.buyPotion = buyPotion;
    window.buySpeed = buySpeed;
    window.closeShop = closeShop;
    window.toggleInv = toggleInv;
    window.closeInv = closeInv;
    window.selectClass = selectClass;
    window.equipItem = equipItem;
    window.resetGame = resetGame;

    // ---------- å°æç¤ºï¼š å¯ç”¨å£°éŸ³å‰è¯·å…ˆè§¦å‘ä¸€æ¬¡ç”¨æˆ·æ‰‹åŠ¿ï¼ˆç‚¹å‡»å±å¹•ï¼‰ -----------
    // (å¯é¸) é»æ“Šä»»æ„è™•æ¿€æ´» audio contextï¼ˆéƒ¨åˆ†æ‰‹æ©Ÿéœ€è¦ï¼‰
    canvas.addEventListener('pointerdown', () => { try { ensureAudio(); if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); } catch(e){} }, {passive:true});
    </script>
</body>
</html>
