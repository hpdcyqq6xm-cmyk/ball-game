<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>MMORPG - Mobile UX Optimized</title>
<style>
  :root{
    --ui-bg: rgba(0,0,0,0.6);
    --accent: #4A90E2;
    --accent-2: #FFD700;
    --safe-margin: 12px;
    --btn-size: 72px; /* base size (scaled on larger screens) */
  }
  *{box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
  html,body{height:100%;margin:0;background:linear-gradient(135deg,#05060a,#13131d);font-family:Inter, "Helvetica Neue", Arial, sans-serif;color:#fff;overflow:hidden;touch-action:none;}
  canvas{display:block;width:100vw;height:100vh;background:radial-gradient(circle at center,#2a2a4a 0%, #0f0f14 70%);cursor:none;}

  /* top status panel */
  #status {
    position:fixed;left:var(--safe-margin);top:var(--safe-margin);
    background:linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
    padding:10px 12px;border-radius:12px;backdrop-filter: blur(6px);
    box-shadow: 0 6px 20px rgba(0,0,0,0.6); z-index:120;
    font-size:14px;line-height:1.1;
  }
  #status div{margin:4px 0; color:#e6eef9; font-weight:600; letter-spacing:0.2px;}

  /* right-side quick buttons */
  .corner-btn{
    position:fixed; right:var(--safe-margin); width:48px; height:48px; border-radius:12px;
    display:flex;align-items:center;justify-content:center; font-size:22px;
    background:var(--ui-bg); border:1px solid rgba(255,255,255,0.06); z-index:120; touch-action: manipulation;
    box-shadow: 0 8px 18px rgba(0,0,0,0.6);
  }
  #shopBtn{ top:calc(50% - 26px - 80px); }
  #invBtn{ top:calc(50% - 26px); }
  #settingsBtn{ top:calc(50% - 26px + 80px); }

  /* joystick container (movable) */
  #joystickWrap{
    position:fixed; left:var(--safe-margin); bottom:var(--safe-margin); width:160px; height:160px;
    z-index:110; touch-action:none; display:flex; align-items:center; justify-content:center;
    user-select:none;
  }
  #joystickBg{
    width:140px; height:140px; border-radius:50%;
    background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
    border: 1px solid rgba(255,255,255,0.03); display:flex; align-items:center; justify-content:center;
    transform-origin:center center;
  }
  #knob{
    width:64px; height:64px; border-radius:50%;
    background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04));
    display:flex; align-items:center; justify-content:center; font-size:18px; color:#fff;
    box-shadow: 0 8px 20px rgba(0,0,0,0.6), inset 0 0 8px rgba(255,255,255,0.02);
    touch-action:none;
  }
  #joystickHint{
    position:absolute; left:0; right:0; bottom: -22px; text-align:center; font-size:11px; color:#bcd;
  }

  /* right-bottom skill panel */
  #skillPanel{
    position:fixed; right:var(--safe-margin); bottom:var(--safe-margin); display:flex; gap:12px;
    z-index:110; align-items:end; padding:6px;
  }
  .skill {
    width:var(--btn-size); height:var(--btn-size); min-width:var(--btn-size);
    border-radius:50%; position:relative; display:flex; align-items:center; justify-content:center;
    background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));
    border: 2px solid rgba(255,255,255,0.06); touch-action: manipulation;
    box-shadow: 0 10px 30px rgba(0,0,0,0.6);
    font-size:28px; user-select:none;
  }

  /* cooldown ring overlay using conic gradient */
  .skill .cd {
    position:absolute; inset:0; border-radius:50%; pointer-events:none;
    background: conic-gradient(rgba(255,255,255,0.06) 0deg, rgba(255,255,255,0.02) 360deg);
    opacity:0.95;
    transition:background 120ms linear;
    mix-blend-mode: screen;
  }
  .skill .cd.hidden{ opacity:0; }

  /* small label */
  .skill .label{ position:absolute; bottom:-18px; width:100%; text-align:center; font-size:12px; color:#cfe; }

  /* tooltips / tutorial overlay */
  #tutorial {
    position:fixed; left:0; right:0; top:0; bottom:0; background:linear-gradient(0deg, rgba(0,0,0,0.75), rgba(0,0,0,0.6)); z-index:200;
    display:flex; align-items:center; justify-content:center; padding:20px;
  }
  #tutorial .card{
    background:rgba(20,24,30,0.95); padding:18px; border-radius:14px; max-width:420px; text-align:left; color:#eaf6ff;
    box-shadow: 0 12px 40px rgba(0,0,0,0.7);
  }
  #tutorial .card h2{ margin:0 0 8px 0; font-size:18px; }
  #tutorial .card p{ font-size:14px; color:#cde; margin:6px 0; line-height:1.4; }
  #tutorial button { margin-top:12px; display:block; width:100%; padding:10px; border-radius:10px; border:none; background:var(--accent); color:#001; font-weight:700; }

  /* responsive tweaks */
  @media (max-width:420px){
    :root{ --btn-size:64px; }
    #joystickWrap{ width:140px; height:140px; }
    #knob{ width:56px; height:56px;}
    .corner-btn{ width:44px; height:44px; font-size:20px;}
  }
</style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <div id="status" aria-live="polite">
    <div id="statClass">è·æ¥­: <strong id="playerClass">æœªé¸</strong></div>
    <div>ç­‰ç´š <span id="playerLevel">1</span>  HP <span id="playerHp">100</span>/<span id="playerMaxHp">100</span></div>
    <div>é‡‘å¹£ <span id="gold">0</span> | æ€ªç‰© <span id="monsterCount">0</span></div>
  </div>

  <!-- corner quick buttons -->
  <button id="shopBtn" class="corner-btn" aria-label="å•†åº—">ğŸ›’</button>
  <button id="invBtn" class="corner-btn" aria-label="èƒŒåŒ…">ğŸ’</button>
  <button id="settingsBtn" class="corner-btn" aria-label="è¨­å®š">âš™ï¸</button>

  <!-- movable joystick -->
  <div id="joystickWrap" aria-hidden="true" title="æ‹–å‹•æ–æ¡¿ä»¥ç§»å‹•ï¼ˆé•·æŒ‰å¯æ‹–æ›³é‡å®šä½ï¼‰">
    <div id="joystickBg">
      <div id="knob">â—</div>
      <div id="joystickHint">æ‹–å‹•ç§»å‹•</div>
    </div>
  </div>

  <!-- right-bottom skill area -->
  <div id="skillPanel" aria-hidden="false">
    <div class="skill" id="skillA" data-index="0" role="button" aria-label="æŠ€èƒ½ä¸€">
      âš”ï¸
      <div class="cd" id="cdA"></div>
      <div class="label">Q</div>
    </div>
    <div class="skill" id="skillB" data-index="1" role="button" aria-label="æŠ€èƒ½äºŒ">
      ğŸŒ€
      <div class="cd" id="cdB"></div>
      <div class="label">E</div>
    </div>
    <div class="skill" id="skillC" data-index="2" role="button" aria-label="æŠ€èƒ½ä¸‰">
      ğŸ¹
      <div class="cd" id="cdC"></div>
      <div class="label">R</div>
    </div>
  </div>

  <!-- tutorial overlay -->
  <div id="tutorial" role="dialog" aria-modal="true">
    <div class="card">
      <h2>è§¸æ§æ•™å­¸ï¼ˆå¿«é€Ÿé–‹å§‹ï¼‰</h2>
      <p>â€¢ å·¦ä¸‹æ‹–æ›³æ–æ¡¿ç§»å‹•ã€‚é•·æŒ‰æ–æ¡¿å¯æ‹–å‹•ä½ç½®è‡³ä»»æ„è§’è½ã€‚</p>
      <p>â€¢ å³ä¸‹ç‚ºæŠ€èƒ½æŒ‰éˆ•ï¼šé»æ“Šæ–½æ”¾ï¼›åœ“ç’°ä»£è¡¨å†·å»ã€‚</p>
      <p>â€¢ é»æ“Šç•«é¢ä»»æ„ä½ç½®å¯å¿«é€Ÿç§»å‹•è‡³è©²è™•ï¼ˆçŸ­é»/çŸ­æ»‘ï¼‰ã€‚é›™æ“Šç•«é¢æˆ–é›™æŒ‡ä¸Šæ»‘å¯é–ƒé¿ã€‚</p>
      <button id="gotItBtn">é–‹å§‹éŠæˆ²</button>
    </div>
  </div>

<script>
/* ===============================
   Setup canvas / DPR handling
   =============================== */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let dpr = Math.max(1, window.devicePixelRatio || 1);
function resize(){
  canvas.style.width = window.innerWidth + 'px';
  canvas.style.height = window.innerHeight + 'px';
  canvas.width = Math.floor(window.innerWidth * dpr);
  canvas.height = Math.floor(window.innerHeight * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', resize);
resize();

/* ===============================
   Game state (kept simple)
   =============================== */
let playerClass = 'æœªé¸';
let player = {
  x: canvas.width/dpr/2, y: canvas.height/dpr/2,
  size: 28, hp:100, maxHp:100, level:1, exp:0, nextExp:100, gold:0,
  speed:5, dmgMod:1, aoeRange:60, petActive:false, dodgeCD:0, dodgeTime:0
};
let monsters = [];
let particles = [];
let projectiles = [];
let inventory = [];
let equipped = { hpBonus:0, dmgBonus:0 };
let gameStarted = false;
let gameOver = false;

/* constants */
const MAX_MONSTERS = 5;
const ATTACK_INTERVAL = 800;
const DODGE_CD = 900; // shorter for mobile feel
const DODGE_TIME = 500;

/* UI elements */
const elPlayerClass = document.getElementById('playerClass');
const elPlayerLevel = document.getElementById('playerLevel');
const elPlayerHp = document.getElementById('playerHp');
const elPlayerMaxHp = document.getElementById('playerMaxHp');
const elGold = document.getElementById('gold');
const elMonsterCount = document.getElementById('monsterCount');

function updateStatusUI(){
  elPlayerClass.textContent = playerClass;
  elPlayerLevel.textContent = player.level;
  elPlayerHp.textContent = Math.max(0, Math.floor(player.hp));
  elPlayerMaxHp.textContent = Math.floor(player.maxHp);
  elGold.textContent = player.gold;
  elMonsterCount.textContent = monsters.filter(m=>m.alive).length;
}

/* ===============================
   Audio / Haptics
   =============================== */
let audioCtx = null;
function ensureAudio(){ if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }
function playSound(freq,duration=0.08,type='sine'){
  try{
    ensureAudio();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.connect(g); g.connect(audioCtx.destination);
    o.type = type; o.frequency.value = freq;
    g.gain.setValueAtTime(0.25,audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.01,audioCtx.currentTime+duration);
    o.start(audioCtx.currentTime); o.stop(audioCtx.currentTime+duration);
  }catch(e){}
}
function vibrate(duration=30){ if(navigator.vibrate) navigator.vibrate(duration); }

/* ===============================
   Spawn monsters / particles
   =============================== */
function spawnMonster(){
  if(!gameStarted) return;
  if(monsters.length < MAX_MONSTERS){
    monsters.push({
      x: Math.random()*(canvas.width/dpr-80)+40,
      y: Math.random()*(canvas.height/dpr-160)+80,
      hp: 40 + player.level*10, maxHp: 40 + player.level*10,
      speed: 1.6 + player.level*0.15, size: 16, lastAttack:0, alive:true, goldDrop: 8 + Math.floor(Math.random()*18)
    });
  }
}
for(let i=0;i<3;i++) spawnMonster();

function createParticles(x,y,color,count=12,spd=3,life=36){
  for(let i=0;i<count;i++){
    particles.push({
      x,y, vx:(Math.random()-0.5)*spd, vy:(Math.random()-0.5)*spd,
      life, maxLife:life, color, size:Math.random()*3+1.5
    });
  }
}
function updateParticles(){
  for(let i=particles.length-1;i>=0;i--){
    let p = particles[i];
    p.x += p.vx; p.y += p.vy; p.life--;
    p.size *= 0.98;
    if(p.life<=0){ particles.splice(i,1); continue; }
    ctx.save();
    ctx.globalAlpha = Math.max(0,p.life/p.maxLife);
    ctx.fillStyle = p.color;
    ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
}

/* ===============================
   Projectiles
   =============================== */
function updateProjectiles(){
  for(let i=projectiles.length-1;i>=0;i--){
    let pr = projectiles[i];
    pr.x += pr.vx; pr.y += pr.vy;
    if(pr.x<-50||pr.x>canvas.width/dpr+50||pr.y<-50||pr.y>canvas.height/dpr+50){ projectiles.splice(i,1); continue;}
    ctx.save(); ctx.translate(pr.x,pr.y); ctx.fillStyle=pr.color; ctx.beginPath(); ctx.arc(0,0,pr.size,0,Math.PI*2); ctx.fill(); ctx.restore();
    for(let j=monsters.length-1;j>=0;j--){
      let m = monsters[j];
      if(m.alive && Math.hypot(m.x-pr.x,m.y-pr.y)<28){
        m.hp -= (22 + player.level*3) * player.dmgMod;
        createParticles(m.x,m.y,'#FFD700',18,4); playSound(880,0.08);
        projectiles.splice(i,1);
        if(m.hp<=0) killMonster(m);
        break;
      }
    }
  }
}

/* ===============================
   Kill & loot & levelup
   =============================== */
function killMonster(m){
  if(!m) return;
  player.exp += 20 + player.level*5;
  player.gold += m.goldDrop;
  createParticles(m.x,m.y,'#FF4444',26,6);
  playSound(240,0.12,'square'); vibrate(18);
  dropLoot();
  if(player.exp>=player.nextExp) levelUp();
  m.alive=false;
  setTimeout(()=>{ let idx = monsters.indexOf(m); if(idx>-1) monsters.splice(idx,1); },700);
}
function dropLoot(){
  if(Math.random() < 0.22){
    let names = playerClass==='warrior'?['éµåŠ','æˆ°æ–§']:playerClass==='mage'?['æ³•æ–','é­”æ™¶']:['çµå¼“','ç®­è¢‹'];
    let loot = { name: names[Math.floor(Math.random()*names.length)], rarity: Math.random()>0.6?'ç´«':Math.random()>0.3?'è—':'ç¶ ', hp:15+Math.random()*36, dmg:4+Math.random()*12 };
    inventory.push(loot);
    createParticles(player.x,player.y,'#FFD700',12,4); playSound(1000,0.12);
  }
}
function levelUp(){
  player.level++; player.exp = 0; player.nextExp = Math.floor(player.nextExp*1.5);
  player.maxHp += 30 + equipped.hpBonus*0.1; player.hp = player.maxHp; player.speed += 0.35;
  createParticles(player.x,player.y,'#00FF88',50,10); playSound(1200,0.18); vibrate(30);
}

/* ===============================
   Skills: cooldown handling + UI
   =============================== */
const skills = [
  {name:'dashSlash', key:'q', cd:1500, active:false, cdTime:0},
  {name:'spinSlash', key:'e', cd:2600, active:false, cdTime:0},
  {name:'arrow', key:'r', cd:2200, active:false, cdTime:0}
];
function useSkill(i){
  const s = skills[i];
  if(Date.now() - s.cdTime < s.cd) return;
  s.cdTime = Date.now();
  s.active = true;
  playSound(900 + i*160,0.08); vibrate(10);
  setTimeout(()=>{ s.active=false; },260);
  // skill-specific effects simplified:
  if(s.name === 'arrow'){
    let angle = Math.random()*Math.PI*2;
    projectiles.push({ x:player.x, y:player.y, vx:Math.cos(angle)*10, vy:Math.sin(angle)*10, size:4, color:'#FFD700' });
  } else {
    // AOE damage to nearby monsters
    monsters.forEach(m=>{
      if(m.alive && Math.hypot(m.x-player.x,m.y-player.y) < (50 + player.aoeRange*0.6)){
        m.hp -= (30 + player.level*4) * player.dmgMod;
        createParticles(m.x,m.y,'#FFAA00',10,4);
        if(m.hp<=0) killMonster(m);
      }
    });
  }
  updateSkillUI();
}
function updateSkillUI(){
  skills.forEach((s,idx)=>{
    const el = document.getElementById(['cdA','cdB','cdC'][idx]);
    const elapsed = Date.now() - s.cdTime;
    let progress = Math.max(0, Math.min(1, elapsed / s.cd));
    // render conic gradient degrees (360 * progress)
    const degrees = progress * 360;
    el.style.background = `conic-gradient(rgba(255,255,255,0.04) ${degrees}deg, rgba(0,0,0,0.0) 0deg)`;
    el.style.opacity = progress >= 1 ? 0 : 0.95;
  });
}

/* ===============================
   Movement: joystick & tap-to-move & dodge gestures
   =============================== */
let targetX = player.x, targetY = player.y, hasTarget = false;
let lastTap = 0;
canvas.addEventListener('pointerdown', (e)=>{
  // ignore if clicking UI (we check target)
  const hit = document.elementFromPoint(e.clientX, e.clientY);
  if(hit && (hit.closest('.skill') || hit.closest('#joystickWrap') || hit.closest('.corner-btn') )) return;
  // set target move
  const rect = canvas.getBoundingClientRect();
  targetX = (e.clientX - rect.left) * (canvas.width/rect.width) / dpr;
  targetY = (e.clientY - rect.top) * (canvas.height/rect.height) / dpr;
  hasTarget = true;
  // double-tap to dodge
  const now = Date.now();
  if(now - lastTap < 280){
    attemptDodge();
    lastTap = 0;
  } else lastTap = now;
});

// dodge function
function attemptDodge(){
  if(Date.now() - player.dodgeCD > DODGE_CD){
    player.dodgeTime = Date.now() + DODGE_TIME; player.dodgeCD = Date.now();
    createParticles(player.x,player.y,'#00FFFF',24,6); playSound(1400,0.08); vibrate(20);
  }
}

/* joystick: movable + double-tap for dash */
const joystickWrap = document.getElementById('joystickWrap');
const joystickBg = document.getElementById('joystickBg');
const knob = document.getElementById('knob');
let joy = { active:false, id:null, start:{x:0,y:0}, pos:{x:0,y:0}, dx:0, dy:0, relocated:false };
const JOY_MAX = 44;

joystickBg.addEventListener('pointerdown', (e)=>{
  e.preventDefault();
  joystickBg.setPointerCapture(e.pointerId);
  joy.active = true; joy.id = e.pointerId;
  const rect = joystickBg.getBoundingClientRect();
  joy.start = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
});
joystickBg.addEventListener('pointermove', (e)=>{
  if(!joy.active || e.pointerId !== joy.id) return;
  updateJoystick(e.clientX, e.clientY);
});
joystickBg.addEventListener('pointerup', (e)=>{
  if(e.pointerId !== joy.id) return;
  joy.active=false; joy.id=null; joy.dx=0; joy.dy=0;
  knob.style.transform = 'translate(-50%,-50%)';
  joy.pos = {x:0,y:0};
});
function updateJoystick(cx, cy){
  const dx = cx - joy.start.x, dy = cy - joy.start.y;
  const dist = Math.hypot(dx,dy);
  const angle = Math.atan2(dy,dx);
  const limited = Math.min(JOY_MAX, dist);
  const kx = Math.cos(angle)*limited, ky = Math.sin(angle)*limited;
  knob.style.transform = `translate(calc(-50% + ${kx}px), calc(-50% + ${ky}px))`;
  joy.dx = kx / JOY_MAX; joy.dy = ky / JOY_MAX;
}

/* long-press to reposition joystick */
let longpressTimer = null;
joystickBg.addEventListener('pointerdown', (e)=>{
  if(e.pointerType === 'mouse') return; // only for touch
  longpressTimer = setTimeout(()=>{
    // set relocation mode: allow next drag of the whole joystickWrap
    joy.relocated = true;
    joystickWrap.style.transition = 'transform 0.12s ease-out';
    joystickWrap.animate([{ transform: 'scale(1)' }, { transform: 'scale(0.96)' }, { transform: 'scale(1)' }], {duration:180});
  }, 500);
});
joystickBg.addEventListener('pointerup', (e)=>{ clearTimeout(longpressTimer); longpressTimer=null; joy.relocated=false; });

/* allow dragging joystickWrap when relocated */
let dragId = null;
joystickWrap.addEventListener('pointerdown', (e)=>{
  if(!joy.relocated) return;
  dragId = e.pointerId;
  joystickWrap.setPointerCapture(dragId);
  joystickWrap._start = { x: e.clientX, y: e.clientY, left: joystickWrap.offsetLeft, top: joystickWrap.offsetTop };
});
joystickWrap.addEventListener('pointermove', (e)=>{
  if(dragId !== e.pointerId) return;
  const dx = e.clientX - joystickWrap._start.x, dy = e.clientY - joystickWrap._start.y;
  joystickWrap.style.left = Math.min(window.innerWidth - 80, Math.max(8, joystickWrap._start.left + dx)) + 'px';
  joystickWrap.style.bottom = 'var(--safe-margin)'; // keep bottom anchored for simplicity
});
joystickWrap.addEventListener('pointerup', (e)=>{
  if(dragId !== e.pointerId) return;
  joystickWrap.releasePointerCapture(dragId);
  dragId = null; joy.relocated = false;
});

/* multi-finger gestures: two-finger swipe up for dodge */
let activePointers = {};
canvas.addEventListener('pointerdown', (e)=>{ activePointers[e.pointerId] = {x:e.clientX,y:e.clientY,time:Date.now()}; });
canvas.addEventListener('pointerup', (e)=>{
  const start = activePointers[e.pointerId];
  if(start){
    const dy = start.y - e.clientY;
    const dt = Date.now() - start.time;
    if(Object.keys(activePointers).length >= 2 && dy > 60 && dt < 600){
      attemptDodge();
    }
  }
  delete activePointers[e.pointerId];
});

/* ===============================
   Update loop: movement, AI, skills
   =============================== */
function update(){
  if(gameOver || !gameStarted) return;

  // joystick movement has priority
  let vx = 0, vy = 0;
  if(Math.abs(joy.dx) > 0.02 || Math.abs(joy.dy) > 0.02){
    vx = joy.dx * player.speed;
    vy = joy.dy * player.speed;
    hasTarget = false;
  } else if(hasTarget){
    const dx = targetX - player.x, dy = targetY - player.y;
    const dist = Math.hypot(dx,dy);
    if(dist > 8){
      vx += (dx / dist) * player.speed * 0.7;
      vy += (dy / dist) * player.speed * 0.7;
    } else hasTarget = false;
  }

  // dodge motion if active
  if(Date.now() < player.dodgeTime){
    // small burst
    player.x += (vx*0.12) + (player.dodgeDir?player.dodgeDir.x*8:0);
    player.y += (vy*0.12) + (player.dodgeDir?player.dodgeDir.y*8:0);
  } else {
    player.x += vx * 0.06;
    player.y += vy * 0.06;
  }
  // clamp
  player.x = Math.max(player.size, Math.min(canvas.width/dpr - player.size, player.x));
  player.y = Math.max(player.size, Math.min(canvas.height/dpr - player.size, player.y));

  // monsters AI & combat
  let alive = monsters.filter(m=>m.alive);
  alive.forEach(m=>{
    const dx = player.x - m.x, dy = player.y - m.y;
    const dist = Math.hypot(dx,dy);
    if(dist > 40){
      m.x += (dx/dist) * m.speed * 0.9;
      m.y += (dy/dist) * m.speed * 0.9;
    }
    if(dist < 42 && Date.now() - m.lastAttack > 1100){
      if(Date.now() > player.dodgeTime) player.hp -= 8;
      m.lastAttack = Date.now();
      createParticles(player.x, player.y, '#E74C3C', 8, 4);
      playSound(320,0.08); vibrate(12);
    }
    if(dist < 36 && Date.now() - player.lastAttack > ATTACK_INTERVAL && Date.now() > player.dodgeTime){
      m.hp -= (12 + player.level*3) * player.dmgMod;
      player.lastAttack = Date.now();
      createParticles(m.x,m.y,'#4A90E2',8,3);
      if(m.hp<=0) killMonster(m);
    }
  });

  // skill side effects
  skills.forEach((s, idx)=>{
    if(s.active){
      // small area damage handled in useSkill when triggered
    }
  });

  // spawn if needed
  if(alive.length < Math.ceil(MAX_MONSTERS*0.6)) spawnMonster();
  if(player.hp <= 0) gameOver = true;

  // update projs / particles
  updateProjectiles();
  updateParticles();
  updateSkillUI();
  updateStatusUI();
}

/* ===============================
   Drawing
   =============================== */
function draw(){
  // clear
  ctx.clearRect(0,0,canvas.width/dpr, canvas.height/dpr);

  // subtle background texture
  ctx.fillStyle = 'rgba(100,150,255,0.008)';
  for(let i=0;i<30;i++){
    ctx.beginPath(); ctx.arc(Math.random()*canvas.width/dpr, Math.random()*canvas.height/dpr, 0.6,0,Math.PI*2); ctx.fill();
  }

  // projectiles drawn earlier in updateProjectiles

  // player
  ctx.save();
  ctx.translate(player.x, player.y);
  ctx.shadowBlur = 24;
  ctx.shadowColor = '#4A90E2';
  ctx.fillStyle = '#27AE60';
  ctx.beginPath(); ctx.arc(0,0,player.size,0,Math.PI*2); ctx.fill();
  ctx.restore();

  // hp bar above player
  const barW = Math.min(140, (canvas.width/dpr)*0.14), bh=12;
  const hpRatio = Math.max(0, player.hp/player.maxHp);
  ctx.fillStyle='rgba(0,0,0,0.7)'; ctx.fillRect(player.x-barW/2, player.y-player.size-26, barW, bh);
  ctx.fillStyle = hpRatio>0.6?'#4CAF50':hpRatio>0.3?'#FF9800':'#F44336';
  ctx.fillRect(player.x-barW/2, player.y-player.size-26, barW*hpRatio, bh);

  // monsters
  monsters.filter(m=>m.alive).forEach(m=>{
    ctx.save(); ctx.translate(m.x,m.y);
    ctx.shadowBlur = 12; ctx.shadowColor = '#E74C3C';
    ctx.fillStyle = '#E74C3C';
    ctx.beginPath(); ctx.arc(0,0,m.size,0,Math.PI*2); ctx.fill();
    ctx.restore();
    const mhRatio = Math.max(0, m.hp/m.maxHp);
    ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(m.x-18, m.y-m.size-18, 36,6);
    ctx.fillStyle = mhRatio>0.6?'#4CAF50':mhRatio>0.3?'#FF9800':'#F44336';
    ctx.fillRect(m.x-18, m.y-m.size-18, 36*mhRatio,6);
  });

  if(gameOver){
    ctx.fillStyle = 'rgba(0,0,0,0.85)'; ctx.fillRect(0,0,canvas.width/dpr, canvas.height/dpr);
    ctx.fillStyle = '#FFD700'; ctx.textAlign='center'; ctx.font = `bold ${Math.min(64, (canvas.width/dpr)*0.08)}px Arial`;
    ctx.fillText('éŠæˆ²çµæŸ', canvas.width/dpr/2, canvas.height/dpr/2);
    ctx.font = `${Math.min(28, (canvas.width/dpr)*0.035)}px Arial`; ctx.fillText('é‡æ•´é é¢æˆ–æŒ‰è·æ¥­é‡æ–°é–‹å§‹', canvas.width/dpr/2, canvas.height/dpr/2+48);
  }
}

/* ===============================
   Main loop
   =============================== */
let lastTime = performance.now();
function loop(){
  const now = performance.now();
  const dt = Math.min(40, now - lastTime)/1000;
  lastTime = now;
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();

/* ===============================
   Skill buttons wiring (touch-friendly)
   =============================== */
function bindSkillEl(id, idx){
  const el = document.getElementById(id);
  el.addEventListener('pointerdown', (e)=>{ e.preventDefault(); useSkill(idx); el.animate([{transform:'scale(1)'},{transform:'scale(0.95)'},{transform:'scale(1)'}],{duration:140}); });
  el.addEventListener('touchstart', (e)=>{ e.preventDefault(); }, {passive:false});
}
bindSkillEl('skillA',0); bindSkillEl('skillB',1); bindSkillEl('skillC',2);

/* ===============================
   Skill UI is updated via updateSkillUI() earlier
   =============================== */

/* ===============================
   Shop / Inventory / Settings
   =============================== */
document.getElementById('shopBtn').addEventListener('pointerdown', (e) => {
  e.preventDefault();
  vibrate(10); playSound(700,0.06);
  alert(`å•†åº—ï¼ˆç¤ºç¯„ï¼‰\nä½ ç›®å‰æœ‰ ${player.gold} é‡‘å¹£ã€‚`);
});
document.getElementById('invBtn').addEventListener('pointerdown', (e) => {
  e.preventDefault();
  vibrate(10); playSound(800,0.06);
  let s = inventory.length ? inventory.map((it,i)=>`${i+1}. ${it.name} [${it.rarity}] +${Math.floor(it.hp)}HP +${Math.floor(it.dmg)}å‚·`).join('\n') : 'èƒŒåŒ…ç©º';
  alert(`èƒŒåŒ…å…§å®¹ï¼š\n${s}`);
});
document.getElementById('settingsBtn').addEventListener('pointerdown', (e) => {
  e.preventDefault();
  vibrate(8); playSound(500,0.06);
  alert('è¨­å®šï¼ˆç¤ºç¯„ï¼‰:\nå¯åœ¨æ­¤åŠ å…¥éŸ³é‡ã€è§¸è¦ºã€æ§åˆ¶æ„Ÿåº¦è¨­å®šã€‚');
});

/* ===============================
   Tutorial / start flow
   =============================== */
const tutorial = document.getElementById('tutorial');
document.getElementById('gotItBtn').addEventListener('pointerdown', (e)=>{
  e.preventDefault();
  tutorial.style.display = 'none';
  gameStarted = true; // start game loop behaviour
  // resume audio on first gesture for mobile
  try{ ensureAudio(); if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); }catch(e){}
  playSound(1000,0.12); vibrate(25);
});

/* ===============================
   Simple class selection (for demo)
   =============================== */
function selectClass(cls){
  playerClass = cls;
  const cfg = { warrior:{speed:4.6,dmg:1.5,aoe:50,pet:false}, mage:{speed:5.4,dmg:1.2,aoe:90,pet:false}, ranger:{speed:5.0,dmg:1.3,aoe:70,pet:true}};
  const c = cfg[cls] || cfg.ranger;
  player.speed = c.speed; player.dmgMod = c.dmg; player.aoeRange = c.aoe; player.petActive = c.pet;
  updateStatusUI();
}
// auto choose ranger for demo
selectClass('ranger');

/* ===============================
   Small helper: allow double-tap on joystick to dash (optional)
   =============================== */
let lastJoystickTap = 0;
joystickBg.addEventListener('pointerdown', (e)=>{
  const now = Date.now();
  if(now - lastJoystickTap < 280){
    // dash forward in current direction
    if(Math.abs(joy.dx)>0.2 || Math.abs(joy.dy)>0.2){
      player.x += joy.dx*40; player.y += joy.dy*40; createParticles(player.x,player.y,'#FFAA66',16,6); playSound(1300,0.08); vibrate(20);
    }
    lastJoystickTap = 0;
  } else lastJoystickTap = now;
});

/* ===============================
   Expose some debug functions to window
   =============================== */
window._useSkill = useSkill;
window._spawn = spawnMonster;
window._stats = ()=>({player,monsters:monsters.length,inv:inventory.length});
</script>
</body>
</html>